<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>easydotmaker</title>
<style>
  body { margin: 0; display: flex; height: 100vh; font-family: sans-serif; }
  #left-panel { width: 25%; background: #f0f0f0; padding: 10px; box-sizing: border-box; overflow-y: auto; }
  #right-panel { flex: 1; display: flex; justify-content: center; align-items: center; background: #fff; }
  #palette { display: grid; grid-template-columns: repeat(8, 20px); gap: 4px; margin-top: 10px; }
  .palette-color { width: 20px; height: 20px; border: 1px solid #ccc; cursor: pointer; }
  #dot-canvas { image-rendering: pixelated; border: 1px solid #444; background: transparent; }
  .tool-btn { margin: 2px 0; display:block; }
</style>
</head>
<body>
<div id="left-panel">
  <h3>カラーサークル（HSV）</h3>
  <input type="color" id="color-picker" />
  <button class="tool-btn" id="save-color">選択色をパレットへ</button>
  <button class="tool-btn" id="eyedropper">スポイト</button>

  <h3>パレット</h3>
  <div id="palette"></div>

  <h3>描画ツール</h3>
  <button class="tool-btn" id="tool-pencil">ペン</button>
  <button class="tool-btn" id="tool-rectsel">矩形選択</button>
  <button class="tool-btn" id="tool-lasso">投げ縄選択</button>
  <button class="tool-btn" id="tool-fill">塗りつぶし</button>
  <button class="tool-btn" id="tool-move">移動</button>
  <button class="tool-btn" id="tool-bright+">明るく</button>
  <button class="tool-btn" id="tool-bright-">暗く</button>

  <h3>キャンバスサイズ</h3>
  <input type="number" id="canvas-size" value="32" min="4" max="256" />
  <button class="tool-btn" id="resize-canvas">変更</button>

  <h3>倍率</h3>
  <button class="tool-btn" id="zoom-in">＋</button>
  <button class="tool-btn" id="zoom-out">−</button>

  <h3>罫線太線間隔</h3>
  <input type="number" id="grid-interval" value="8" min="1" />

  <h3>出力</h3>
  <button class="tool-btn" id="export-png">PNG出力</button>
</div>

<div id="right-panel">
  <canvas id="dot-canvas" width="256" height="256"></canvas>
</div>

<script>
// ====== 基本状態 ======
let size = 32;
let scale = 16;
let currentColor = '#000000';
let eyedrop = false;
let tool = 'pencil';
let selectionMask = null;
let lassoPoints = [];
let isDragging = false;
let dragStart = null;

// データ: 透明は rgba(0,0,0,0)
let data = createEmpty(size);

function createEmpty(n){ return Array(n).fill().map(()=>Array(n).fill('rgba(0,0,0,0)')); }

// ====== Canvas ======
const canvas = document.getElementById('dot-canvas');
const ctx = canvas.getContext('2d');

function draw(){
  canvas.width = size * scale;
  canvas.height = size * scale;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Draw pixels
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      ctx.fillStyle = data[y][x];
      ctx.fillRect(x*scale,y*scale,scale,scale);
    }
  }

  // Selection mask preview
  if(selectionMask){
    ctx.fillStyle = 'rgba(0,128,255,0.3)';
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        if(selectionMask[y][x]) ctx.fillRect(x*scale,y*scale,scale,scale);
      }
    }
  }

  // Grid
  ctx.strokeStyle = '#ccc';
  for(let i=0;i<=size;i++){
    ctx.beginPath(); ctx.moveTo(i*scale,0); ctx.lineTo(i*scale,size*scale); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,i*scale); ctx.lineTo(size*scale,i*scale); ctx.stroke();
  }
  const interval = parseInt(document.getElementById('grid-interval').value,10);
  ctx.strokeStyle = '#000';
  for(let i=0;i<=size;i+=interval){
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(i*scale,0); ctx.lineTo(i*scale,size*scale); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,i*scale); ctx.lineTo(size*scale,i*scale); ctx.stroke();
    ctx.lineWidth = 1;
  }
}
draw();

// ====== パレット ======
const paletteEl = document.getElementById('palette');
let palette = Array(64).fill('rgba(0,0,0,0)');

function renderPalette(){
  paletteEl.innerHTML='';
  palette.forEach(c=>{
    const d=document.createElement('div');
    d.className='palette-color'; d.style.background=c;
    d.onclick=()=> currentColor=c;
    paletteEl.appendChild(d);
  });
}
renderPalette();

document.getElementById('save-color').onclick=()=>{
  const i=palette.findIndex(c=>c==='rgba(0,0,0,0)');
  palette[i>=0?i:palette.length-1]=currentColor;
  renderPalette();
};

// ====== ツール切替 ======
function setTool(t){ tool=t; lassoPoints=[]; selectionMask=null; draw(); }

document.getElementById('tool-pencil').onclick=()=>setTool('pencil');
document.getElementById('tool-rectsel').onclick=()=>setTool('rectsel');
document.getElementById('tool-lasso').onclick=()=>setTool('lasso');
document.getElementById('tool-fill').onclick=()=>setTool('fill');
document.getElementById('tool-move').onclick=()=>setTool('move');

document.getElementById('tool-bright+').onclick=()=> adjustSelection(20);
document.getElementById('tool-bright-').onclick=()=> adjustSelection(-20);

// ====== 色調補正 ======
function adjustSelection(v){
  if(!selectionMask) return;
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      if(selectionMask[y][x] && data[y][x].startsWith('rgba(')){
        let [r,g,b,a] = data[y][x].replace('rgba(','').replace(')','').split(',').map(Number);
        r=Math.min(255,Math.max(0,r+v));
        g=Math.min(255,Math.max(0,g+v));
        b=Math.min(255,Math.max(0,b+v));
        data[y][x]=`rgba(${r},${g},${b},${a})`;
      }
    }
  }
  draw();
}

// ====== キャンバス リサイズ ======
document.getElementById('resize-canvas').onclick=()=>{
  const newSize=parseInt(document.getElementById('canvas-size').value);
  const newData=createEmpty(newSize);
  for(let y=0;y<Math.min(size,newSize);y++){
    for(let x=0;x<Math.min(size,newSize);x++){
      newData[y][x]=data[y][x];
    }
  }
  size=newSize;
  data=newData;
  draw();
};

// ====== Fill ======
function floodFill(x,y){
  const target=data[y][x];
  if(target===currentColor) return;
  const q=[[x,y]];
  while(q.length){
    const [cx,cy]=q.pop();
    if(cx<0||cy<0||cx>=size||cy>=size) continue;
    if(data[cy][cx]!==target) continue;
    data[cy][cx]=currentColor;
    q.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
  }
}

// ====== 選択ツール（矩形 / 投げ縄） ======
function commitRectSelection(sx,sy,ex,ey){
  selectionMask=createEmpty(size).map(row=>row.map(()=>false));
  for(let y=Math.min(sy,ey);y<=Math.max(sy,ey);y++){
    for(let x=Math.min(sx,ex);x<=Math.max(sx,ex);x++){
      if(x>=0&&y>=0&&x<size&&y<size) selectionMask[y][x]=true;
    }
  }
}

function pointInPoly(px,py,pts){
  let c=false;
  for(let i=0,j=pts.length-1;i<pts.length;j=i++){
    const xi=pts[i].x, yi=pts[i].y;
    const xj=pts[j].x, yj=pts[j].y;
    const intersect=((yi>py)!=(yj>py)) && px < (xj-xi)*(py-yi)/(yj-yi)+xi;
    if(intersect) c=!c;
  }
  return c;
}

function commitLasso(){
  selectionMask=createEmpty(size).map(row=>row.map(()=>false));
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      if(pointInPoly(x,y,lassoPoints)) selectionMask[y][x]=true;
    }
  }
}

// ====== Canvas interaction ======
let selStart=null;

canvas.addEventListener('mousedown',e=>{
  const rect=canvas.getBoundingClientRect();
  const x=Math.floor((e.clientX-rect.left)/scale);
  const y=Math.floor((e.clientY-rect.top)/scale);
  if(x<0||y<0||x>=size||y>=size) return;

  if(tool==='pencil'){
    if(eyedrop){ currentColor=data[y][x]; eyedrop=false; return; }
    data[y][x]=currentColor;
  }
  else if(tool==='fill'){ floodFill(x,y); }
  else if(tool==='rectsel'){ selStart={x,y}; selectionMask=null; }
  else if(tool==='lasso'){ lassoPoints=[{x,y}]; selectionMask=null; }
  else if(tool==='move'){ selStart={x,y}; isDragging=true; }

  draw();
});

canvas.addEventListener('mousemove',e=>{
  const rect=canvas.getBoundingClientRect();
  const x=Math.floor((e.clientX-rect.left)/scale);
  const y=Math.floor((e.clientY-rect.top)/scale);
  if(x<0||y<0||x>=size||y>=size) return;

  if(e.buttons===1 && tool==='pencil'){
    data[y][x]=currentColor;
    draw();
  }
  if(e.buttons===1 && tool==='lasso'){
    lassoPoints.push({x,y}); draw();
  }
});

canvas.addEventListener('mouseup',e=>{
  const rect=canvas.getBoundingClientRect();
  const x=Math.floor((e.clientX-rect.left)/scale);
  const y=Math.floor((e.clientY-rect.top)/scale);

  if(tool==='rectsel' && selStart){ commitRectSelection(selStart.x,selStart.y,x,y); }
  if(tool==='lasso'){ commitLasso(); }

  selStart=null;
  isDragging=false;
  draw();
});

// ====== Export ======
document.getElementById('export-png').onclick=()=>{
  const out=document.createElement('canvas'); out.width=size; out.height=size;
  const octx=out.getContext('2d');
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      octx.fillStyle=data[y][x]; octx.fillRect(x,y,1,1);
    }
  }
  const link=document.createElement('a'); link.download='dot.png'; link.href=out.toDataURL(); link.click();
};

</script>
</body>
</html>